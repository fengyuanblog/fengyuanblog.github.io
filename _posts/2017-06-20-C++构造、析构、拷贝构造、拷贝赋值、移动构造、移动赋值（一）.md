---
layout: post
date: 2017-06-20
title: C++构造、析构、拷贝构造、拷贝赋值、移动构造、移动赋值（一）
category: C++语言
tag: C++类
author: Feng Yuan
---

* content
{: toc}



## 一、概述

C++中的这几个函数，构成了对对象进行资源管理的核心部分，即使智能指针也是通过对这些基本方法的封装来实现的。本文详细总结类中的这几个重要的方法。

C++中进行资源管理有一项重要的原则：RAII（Resource Acquisition is Initialisation）。获取资源就是初始化对象（构造对象），释放资源就是析构对象。这个原则表明，内存管理就是对对象的管理，所有的内存管理方法应该放在类定义中，在程序中应该避免裸露的new和delete。这一条在纯面向对象语言中（JAVA、C#等），是默认的。

这几个函数的基本Syntax如下：

```c++
class T{
    T();                //默认的构造函数
    T(SomeType);        //普通的构造函数
    T(const T&);        //拷贝构造函数
    T(T&&);             //移动构造函数
    T& operator=(const T&); //拷贝赋值函数
    T& operator=(T&&);      //移动赋值函数
    ~T();                   //析构函数
}
```

## 二、构造函数

### 1.原则

构造函数需要在构造之后保持类的不变性（即class invariant)。类成员之间有的时候需要满足一组约束条件，class invariant 要求在对类的对象进行任意操作之后，仍然保持这组约束条件。当然，这在构造对象的时候，就必须满足了。

### 2.构造函数的调用

构造函数一般在对象初始化的时候进行调用（这个对象可以是有名字的变量，也可以是临时变量）

构造函数调用顺序：

a. ***调用父类构造函数；***
b. ***调用类成员的构造函数；***
c. ***调用构造函数体。***

### 3.类对象的初始化

#### 1)无构造函数的类的初始化方式

a. 按照成员对应初始化

对于没有构造函数的类，其中的public的成员，可以通过提供对应成员变量的初始化值的列表对整个对象进行初始化。(这种方式只能对类中的public成员有用，有private非静态成员的类只能通过构造函数初始化）
```c++
class T{
public:
    string s;
    int a;
    char * p;
}
T obj_1={"string", 1, nullptr};
```

b. 拷贝初始化

可以在新建对象的时候，拷贝一个已有的对象，完成对新对象的初始化。（这种形式其实是调用了默认的拷贝构造函数，进行memberwise的浅拷贝初始化）
```c++
T obj_2{obj_1};  /*浅拷贝初始化了obj_2.obj_2具有和obj_1一样的成员.*/
```

c. 默认初始化

可以不使用显式初始化或者使用空的{}来实现默认初始化（本质上编译器提供一个默认构造函数，调用默认构造函数对类对象进行简单初始化）。如果显式使用{}初始化，将强制调用默认构造函数对所有成员进行初始化；如果不使用{}，那么若对象是global或者static的，对所有成员进行初始化，否则（局部变量，建立在堆上），对built-in类型的成员将不进行初始化。
```c++
static T obj_3;     /*初始化成{“”，0，nullptr}*/
T obj_4{};          /*等同于前者*/
void f(){T obj_5;}  /*int将处于非初始化状态*/
```

**浅拷贝**：只是将指针成员的内容（地址）进行了拷贝，其所指向的变量的内容并没有被拷贝。

```c++
char * tmp=new char{'a'};
cout << "The address of tmp is : " << static_cast<void*>(tmp) << endl;
T obj_6={"string", 0, tmp};
cout << static_cast<void*>(obj_6.p) << endl;
T obj_7{obj_6};
cout << static_cast<void*>(obj_7.p) << endl;
```

可以看到，上述代码中输出的地址是相同的，也就是说仅仅对指针的值进行了拷贝。

#### 2)使用构造函数的初始化

对于定义了构造函数的类，执行初始化的时候，自动调用这个构造函数进行初始化，如果初始化参数没有跟任何一个构造函数相匹配，报错。可以使用‘{}’，‘()’，或者赋值对对象进行构造函数的调用，其中()是对构造函数的显式调用。一般这三种调用没有区别，只有在container中，由于使用初始化列表作为参数的构造函数和使用元素类型T作为参数的构造函数定义不同，{T}和(T)的调用才明显不同。使用构造函数进行初始化时，成员的初始化顺序是按照在类中的声明顺序，而不是在构造函数中的执行顺序。
#### 3)默认构造函数

如果没有定义任何构造函数，默认构造函数一般由编译器自动补充。如果定义了构造函数，默认构造函数将被抑制。一般来说，默认构造函数不带任何参数（也可以带有单一具有默认值的参数）。默认构造函数可以带成员初始化列表，来完成对类成员的特定初始化。built-in类型的成员，如果对象不是static或者global的，不会被默认构造函数初始化。

对于在container中使用的类型，一般需要定义默认构造函数，这样可以保证container对象在构造时，对其成员对象正确初始化。

#### 4)使用初始化列表的构造函数

`std::initializer_list`是C++标准库中的一个类型，使用这种类型作为参数的构造函数就称作“初始化列表构造函数”。

使用初始化列表对对象进行初始化的好处是，对对象的数目没有限制，可以传递变长的参数。
```c++
class T{
public:
    char * p;
    T(initializer_list<char> list){
        p=new char[list.size()];
        for (int i=0;i!=list.size();i++){
            p[i]=list.begin()[i];}
    }
    ~T(){delete [] p;}
}
T obj1{'a','b','c','d','e'};//使用初始化列表显式调用构造函数
T obj2={'a','b','c'};/*注意，由于构造函数没有使用explicit声明，因此，支持隐式转换*/
```

当同时定义了默认构造函数，初始化列表构造函数，和普通构造函数的时候，重载的优先级，遵循上述顺序。

### 4.类成员的初始化

#### 1)成员初始化列表

一个类的构造函数体总是在类成员初始化结束后进行。因此，在函数体前面加入一个以:开头的成员初始化列表，完成对类成员的初始化工作。

无论是否有这个列表，构造函数在执行函数体前，总是要对类成员进行初始化操作（默认或者指定）。因此，对比在函数体中对成员变量进行赋值初始化，使用初始化列表更加高效。
```c++
class T{
public:
    int a;
    double b;
    string c;
    T(int x, double y, string z)
        :a{x},b{y}  //虽然没有在初始化列表中加入对c的初始化，c仍然被默认初始化成“”
    {
        c=z;        //此处再对c进行一次赋值操作，显然，直接使用初始化列表更加高效
    }
}
```

成员初始列表的顺序一般应该与类中成员声明的顺序一致，这样能够保证正确的析构（析构时，按照成员初始化列表的逆序析构）。

#### 2)复用构造函数

在定义了多个构造函数的类中，某一个构造函数可以在函数体中调用其他的构造函数，实现构造函数的复用。

#### 3)In-class 初始化

在类定义中，可以在声明变量的同时对变量进行初始化。或者，构造函数就定义在类定义中，而不是放在其他的地方。这种直接内联到类的初始化方式称作In-Class初始化。其作用是，对于共享的类成员可以统一初始化，避免在多个构造函数中重复编写（复用构造函数也是为了避免重复编写）。
```c++
class T{
public:
    int a {1};
    double b {2.0};//In-class 定义的一种形式
    string s;
    char * p;
    T():s{""},p{nullptr}{} //使用内联的构造函数进行in-class的初始化
}
```

#### 4)static和reference成员的初始化

首先，const和引用类型的成员变量必须在类定义的时候就初始化，一般使用in-class的形式直接初始化。static成员如果没有const声明，必须在类外部进行初始化。

### 5.父类的初始化

父类的初始化总是最先被调用的，先于成员初始化列表和构造函数体。父类初始化的方法，就是写入成员初始化列表，表达形式上并没有什么不同。如果有哪个父类未写入成员初始化列表，则调用该父类的默认构造函数（若父类中未定义，则出错）。

### 6.构造函数中的异常

构造函数在调用的过程中，很可能出现异常，比如new的时候没有足够的内存来分配。抛出异常的时候，很可能类对象仅仅完成了部分构造，未经任何处理的情况下，很可能不满足异常安全。如果此时直接进入异常处理程序，程序的内存状态是不确定的，异常处理完成后，也不知道应该将程序返回到何种状态。因此必须清理已经完成的部分构造。

如果完成的构造是通过new来开辟的内存，抛出异常，会造成leak。

如果遵循RAII原则，完成的构造都是对象，那么抛出异常，在离开类作用域的时候，会自动调用已完成对象的析构函数，安全的释放内存，不会产生leak。

## 三、析构函数

### 1.原则

析构函数是保证类对象在删除时，不会产生任何的内存泄漏。

### 2.析构函数的调用

#### 1）调用的时刻

析构函数在程序离开一个scope时或者使用delete时调用。

析构函数的调用顺序与构造函数的顺序正好相反。

#### 2）显式调用

析构函数极少显式调用，一种特殊情况是，在变长的container中，删除类型为T的元素时，需要显式调用T的析构函数完成删除。

#### 3）禁用析构函数

析构函数可以被声明为private或者使用=delete标注，这样就禁止类的对象被删除。在某些编译器中，这种做法是不会编译通过的。（类必须有析构函数，显式定义或者编译器默认给出）

### 3.虚析构函数

析构函数可以声明成virtual。在有些情况下必须声明成virtual，比如，类本身有virtual的成员函数时。这种具有接口作用的类，virtual成员函数要被override，而且析构函数也要被override。因为不仅一般通过指向子类对象的父类型的指针实现动态多态，而且一般也通过这种父类型的指针进行析构。为了正确对子类对象进行析构，子类中必须override父类的析构函数，否则子类对象使用父类的析构函数不会正确析构。

### 4.析构函数中的异常

一般来说，析构函数中不允许抛出异常。
