---
layout: post
post: true
title: 进程的内存结构（以Java为例）
date: 2019-09-27
category: Java
tag: 进程
author: Feng Yuan
---

* content
{: toc}


### 一、进程中的数据结构
#### **1. 系统中进程的内存分配**
一般来说，操作系统为了隔离的需求，将物理内存分成内核区和用户区。内核区只能由操作系统内核代码访问，就是通常所说的系统调用，也包括对驱动程序的调用（IO）。用户区只能由用户代码访问。在应用层面来说，两个区互相不能访问。这种隔离可以是操作系统设计的，很多时候也是处理机在硬件上设计的（处理机的不同模式下，可以访问不同的内存区，使用不同的寄存器，硬件层面上就已经隔离开不同模式了）。这种隔离造成了很多低效率的问题，比如，用户从IO带缓冲的读取一个字节，需要陷入内核态，把IO数据先读入内核中的缓冲区，之后，通过操作系统将内核缓冲区的数据拷贝到用户内存区，最后，用户程序才能使用数据。

每个进程看到的内存是所谓的虚拟内存，其看到的地址空间范围是操作系统虚拟出来的，所谓逻辑地址空间。这个逻辑地址是要通过寻址过程翻译成实际的物理地址，才能访问，这个物理地址可以是内存中的内核区（内核进程），也可以是用户区（用户进程），也可以是硬盘上的Swap区（虚拟内存）。

在这样的一个逻辑地址空间中，分成代码区和数据区。代码区是将硬盘上的程序文件读入内存用来执行，都是一条条的指令。数据区的分配不同的操作系统安排不同，但是，绝大多数都有堆区和栈区。堆区主要用于随机存储被整个进程共享的变量，又可以细分成：全局变量区，静态变量区，常量池和运行区。栈区是函数调用形成的区域，存储的都是每个函数在自己的栈帧上的局部变量。Unix中的典型内存分配方案见Fig.1。其中，环境变量由于在运行程序前已经确定，且运行中不会发生改变，放在内存的最高地址处，栈区从高地址向低地址增长，堆区相反。全局变量等都放在堆区的底部。

<div align=center><img src="/assets/img/2019/09/27/Unix_Process_Structure.png" width="60%"/><p>Fig.1 Unix 中的典型进程内存分配方案</p></div>

#### **2. 栈区**
Stack由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。

#### **3. 堆区**
Heap是一个可动态申请的内存空间(其记录空闲内存空间的链表由操作系统维护)，在java中,所有使用new xxx()构造出来的对象都在堆中存储。在C中，所有使用malloc()分配的区域都在堆中。堆的使用一般由程序员手动分配和释放，若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配方式倒是类似于*链表*。

>堆是全局的，堆栈是每个函数进入的时候分一小块，函数返回的时候就释放了，静态和全局变量，new得到的变量，都放在堆中，局部变量放在栈中，所以函数返回，局部变量就全没了。

### 二、Java中变量是如何在进程中分配的

#### **1. 栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方**

与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。

#### **2. 栈与堆的优劣**

栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈区是每个线程私有的。

堆的优势是可以动态地分配内存大小，所有使用new xxx()构造出来的对象都在堆中存储，这样就保证了即使在某个栈帧上new出来的对象也不会因为栈帧的销毁（函数返回）而丢失。对象的生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据（当引用计数降为0的时候）。而在C中，如果一个函数malloc了一块内存，也是存放在堆上的，只要函数返回这块内存的的地址就可以了，但是，C中不能返回局部变量的地址（因为地址所指向的内存是在栈帧上的，该栈帧会随着函数的返回而丢失，Java不存在这种问题，所以避免了很多错误）。堆的缺点是，由于要在运行时动态分配内存，存取速度较慢。

#### **３. 常量池：存放字符串常量和基本类型常量（final）**

常量池的好处是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。
>例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。（1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。（2）节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。

#### **４. Java中的数据类型**

一种是基本类型(primitive types), 共有8种，即int, short, long, byte, float, double, boolean, char(注意，不包含String)。另一种是引用类型(reference types),很多中，比如，Integer, Double，String，以及无数由用户自定义的类创建的对象。

如在方法中调用 `int a = 3;` 这里的a是一个指向int类型的引用，指向3这个字面值。这些字面值的数据，由于大小可知，生存期可知(这些字面值固定定义在某个程序块里面，程序块退出后，字段值就消失了)，出于追求速度的原因，就存在于栈中。而对于引用类型的对象，无论是在程序中的哪里new的，都存放在堆中，因为对象的大小不确定，生存周期也不确定，需要最高的灵活性。

#### **５. String类与常量池**

Java中的常量池中存储的也是对象，只不过其值在整个进程存活期间都不发生变化。Java中的常量要么是通过｀final｀标注创建，要么是literal的字符串。前者可以把任何对象放入常量池中，而后者仅仅针对String类。

>注意：static不同于final，static是表示这个变量或者方法属于类的，类的存储区是不同于对象的，对象都是在堆中，而类存放在静态区中(类似于全局变量区)。

**String是一个特殊的包装类数据**

即可以用 `String str = new String("abc");` 的形式来创建，也可以用 `String str = "abc";` 的形式来创建。前者是规范的类的创建过程，即在Java中，一切都是对象，而对象是类的实例，全部通过new()的形式来创建。后者是一个比较简略的写法，将str直接指向常量池。

>作为对比，在JDK 5.0之前，你从未见过 `Integer i = 3;` 的表达式，因为类与字面值是不能通用的，除了String。而在JDK 5.0中，这种表达式是可以的！因为编译器在后台进行 `Integer i = new Integer(3)` 的转换。Java中的有些类，如DateFormat类，可以通过该类的getInstance()方法来返回一个新创建的对象，似乎违反了此原则。其实不然。该类运用了单例模式来返回类的实例，只不过这个实例是在该类内部通过new()来创建的，而getInstance()向外部隐藏了此细节。

那为什么在String str = "abc"；中，并没有通过new()来创建实例，是不是违反了上述原则？其实没有。
Java内部将此语句转化为以下几个步骤：

- 先定义一个名为str的对String类的对象引用变量放入栈中。
- 在常量池中查找是否存在内容为"abc"字符串对象。
- 如果不存在则在常量池中创建"abc"，并让str引用该对象。
- 如果存在则直接让str引用该对象。

为了更好地说明这个问题，我们可以通过以下的几个代码进行验证。

{%highlight java%}
String str1 = "abc";
String str2 = "abc";
System.out.println(str1==str2); //true
{%endhighlight%}

注意，我们这里并不用 `str1.equals(str2)；` 的方式，因为这将比较两个字符串的地值是否相等==号，根据JDK的说明，只有在两个引用都指向了同一个对象时才返回真值。而我们在这里要看的是，str1与str2是否都指向了同一个对象。结果说明，JVM创建了两个引用str1和str2，但只创建了一个对象，而且两个引用都指向了这个对象。

<div align="center"><img src="/assets/img/2019/09/27/Java_String_1.jpg" width="60%"/><p>Fig.2 Java String and Constant Pool</p></div>

我们再来更进一步，将以上代码改成：

{%highlight java%}
String str1 = "abc";
String str2 = "abc";
str1 = "bcd";
System.out.println(str1 + "," + str2); //bcd, abc
System.out.println(str1==str2); //false
{%endhighlight%}

这就是说，赋值的变化导致了类对象引用的变化，str1指向了另外一个新对象！而str2仍旧指向原来的对象。上例中，当我们将str1的值改为"bcd"时，JVM发现在栈中没有存放该值的地址，便开辟了这个地址，并创建了一个新的对象，其字符串的值指向这个地址。 事实上，String类被设计成为不可改变(immutable)的类。如果你要改变其值，可以，但JVM在运行时根据新值悄悄创建了一个新对象，然后将这个对象的地址返回给原来类的引用。这个创建过程虽说是完全自动进行的，但它毕竟占用了更多的时间。在对时间要求比较敏感的环境中，会带有一定的不良影响。

<div align="center"><img src="/assets/img/2019/09/27/Java_String_2.jpg" width="60%" /><p>Fig.3 Java String and Constant Pool 2</p></div>

再修改原来代码：

{%highlight java%}
String str1 = "abc";
String str2 = "abc";
str1 = "bcd";
String str3 = str1;
System.out.println(str3); //bcd
String str4 = "bcd";
System.out.println(str1 == str4); //true
{%endhighlight%}

str3这个对象的引用直接指向str1所指向的对象(注意，str3并没有创建新对象)。当str1改完其值后，再创建一个String的引用 str4，并指向因str1修改值而创建的新的对象。可以发现，这回str4也没有创建新的对象，从而再次实现栈中数据的共享。

<div align="center"><img src="/assets/img/2019/09/27/Java_String_3.jpg" width="60%"/><p>Fig.4 Java String and Constant Pool 3</p></div>

我们再来看看 String str = new String("abc")创建过程:

- 先定义一个名为str的对String类的对象引用变量放入栈中。
- 然后在堆中（不是常量池）创建一个指定的对象，并让str引用指向该对象。
- 在常量池中查找是否存在内容为"abc"字符串对象。
- 如果不存在，则在常量池中创建内容为"abc"的字符串对象，并将堆中的对象与之联系起来。
- 如果存在，则将new出来的字符串对象与字符串常量池中的对象联系起来（即让那个特殊的成员变量value的指针指向它）

我们再接着看以下的代码。

{%highlight java%}
String str1 = new String("abc");
String str2 = "abc";
System.out.println(str1==str2); //false
{%endhighlight%}

创建了两个引用。创建了两个对象。两个引用分别指向不同的两个对象。

>对于字符串：其对象的引用都是存储在栈中的，如果是编译期已经创建好(直接用双引号定义的)的就存储在常量池中，如果是运行期（new出来的）才能确定的就存储在堆中。对于equals相等的字符串，在常量池中永远只有一份，在堆中有多份。这也就是有道面试题：String s = new String(“abc”);产生几个对象？答：一个或两个，如果常量池中原来没有”abc”,就是两个。

String的intern()方法就是扩充常量池的一个方法；当一个String实例str调用intern()方法时，Java查找常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用；

{%highlight java%}
String str1 = "abc";
String str2 = new String("abc");
String str3 = str2.intern();
System.out.println( str1==str2 ); //false
System.out.println( str1==str3 ); //true
{%endhighlight%}

&nbsp;
<div align="center"><img src="/assets/img/2019/09/27/Java_String_4.jpg" width="60%"/><p>Fig.5 Java String and Constant Pool 4</p></div>

**基本数据类型包装类的值不可修改。不仅仅是String类的值不可修改，所有的基本数据数据类型包装类都不能更改其内部的值。其他基本数据类型的包装类与String的差别是，使用`Integer i=3;`创建一个整型变量时，并不是直接在常量池中引用，而是类似`String str=new String('abc')`的过程，需要在堆中创建一个对象，再引用到常量池中的对象。**

**\[结论与建议\]**
- 我们在使用诸如String str = "abc"；的格式定义类时，总是想当然地认为，我们创建了String类的对象str。担心陷阱！对象可能并没有被创建！唯一可以肯定的是，指向 String类的引用被创建了。至于这个引用到底是否指向了一个新的对象，必须根据上下文来考虑，除非你通过new()方法来显要地创建一个新的对象。因此，更为准确的说法是，我们创建了一个指向String类的对象的引用变量str，这个对象引用变量指向了某个值为"abc"的String类。清醒地认识到这一点对排除程序中难以发现的bug是很有帮助的。
- 使用String str = "abc"；的方式，可以在一定程度上提高程序的运行速度，因为JVM会自动根据常量池中数据的实际情况来决定是否有必要创建新对象。而对于String str = new String("abc")；的代码，则一概在堆中创建新对象，而不管其字符串值是否相等，是否有必要创建新对象，从而加重了程序的负担。这个思想应该是享元模式的思想，但JDK的内部在这里实现是否应用了这个模式，不得而知。
- 当比较包装类里面的数值是否相等时，用equals()方法；当测试两个包装类的引用是否指向同一个对象时，用==。
- 由于String类的immutable性质，当String变量需要经常变换其值时，应该考虑使用StringBuffer类，以提高程序效率。

#### **6. Java中数据可以存放的区域**

在JAVA中，有六个不同的地方可以存储数据：

1) 寄存器（register）：这是最快的存储区，因为它位于不同于其他存储区的地方——处理器内部。但是寄存器的数量极其有限，所以寄存器由编译器根据需求进行分配。你不能直接控制，也不能在程序中感觉到寄存器存在的任何迹象。
2) 栈（stack）：存放基本类型的变量数据和对象的引用。位于通用RAM中，但通过它的“堆栈指针”可以从处理器哪里获得支持。堆栈指针若向下移动，则分配新的内存；若向上移动，则释放那些内存。这是一种快速有效的分配存储方法，仅次于寄存器。创建程序时候，JAVA编译器必须知道存储在堆栈内所有数据的确切大小和生命周期，因为它必须生成相应的代码，以便上下移动堆栈指针。这一约束限制了程序的灵活性。
3) 堆（heap）：一种通用性的内存池（也存在于RAM中），用于存放所有的JAVA对象。堆不同于堆栈的好处是：编译器不需要知道要从堆里分配多少存储区 域，也不必知道存储的数据在堆里存活多长时间。因此，在堆里分配存储有很大的灵活性。当你需要创建一个对象的时候，只需要new写一行简单的代码，当执行 这行代码时，会自动在堆里进行存储分配。当然，为这种灵活性必须要付出相应的代价，用堆进行存储分配比用堆栈进行存储存储需要更多的时间。
4) 静态存储（static storage）：这里的“静态”是指“在固定的位置”。静态存储里存放程序运行时一直存在的数据。你可用关键字static来标识一个对象的特定元素是静态的，但JAVA对象本身从来不会存放在静态存储空间里。
5) 常量存储（constant storage）：存放字符串常量和基本类型常量（public static final）。 常量值通常直接存放在程序代码内部，这样做是安全的，因为它们永远不会被改变。
6) 非RAM存储：硬盘等永久存储空间。如果数据完全存活于程序之外，那么它可以不受程序的任何控制，在程序没有运行时也可以存在。

就速度来说，有如下关系：**寄存器 < 栈 < 堆 < 其他**

#### **7. 堆栈缓存方式**

栈使用的是一级缓存， 他们通常都是被调用时处于存储空间中，调用完毕立即释放。

堆则是存放在二级缓存中，生命周期由虚拟机的垃圾回收算法来决定（并不是一旦成为孤儿对象就能被回收）。所以调用这些对象的速度要相对来得低一些。

#### **8.申请响应与申请限制**

栈：只要栈的剩余空间大于所申请空间，系统将为程序提供内存，否则将报异常提示栈溢出。在Windows下,栈是向低地址扩展的数据结构，是一块连续的内存的区域。这句话的意思是栈顶的地址和栈的最大容量是系统预先规定好的，在 WINDOWS下，栈的大小是2M（也有的说是1M，总之是一个编译时就确定的常数），如果申请的空间超过栈的剩余空间时，将提示overflow。因此，能从栈获得的空间较小。

堆：首先应该知道操作系统有一个记录空闲内存地址的链表，当系统收到程序的申请时，会遍历该链表，寻找第一个空间大于所申请空间的堆结点，然后将该结点从空闲结点链表中删除，并将该结点的空间分配给程序，另外，对于大多数系统，会在这块内存空间中的首地址处记录本次分配的大小，这样，代码中的delete语句才能正确的释放本内存空间。另外，由于找到的堆结点的大小不一定正好等于申请的大小，系统会自动的将多余的那部分重新放入空闲链表中。堆是向高地址扩展的数据结构，是不连续的内存区域。这是由于系统是用链表来存储的空闲内存地址的，自然是不连续的，而链表的遍历方向是由低地址向高地址。堆的大小受限于计算机系统中有效的虚拟内存。由此可见，堆获得的空间比较灵活，也比较大。

### 三、线程的内存结构

#### **1. 引入线程的原因**

线程是比进程更小的**执行单元**。

为什么要引入线程呢？进程中既需要保存各种全局变量，常量池，静态区等，也需要分配执行程序的栈区空间。这已经将进程的存储空间分成了两个具有明显不同结构的区域。线程仅仅是保留了执行部分的结构，也就是栈区。这样更加细粒度的进行调度，更好的利用CPU，每次占用CPU的是一个线程，而不是一个进程。

#### **2. 一个线程中都有哪些数据**

- 线程最本质和主要的作用是自己私有的栈，以及处理机状态（一组寄存器的值），这些是保留执行状态的核心。
- 线程需要有一些与执行有关的配置信息，比如，在Unix中，线程包含线程ID（区分不同的线程），调度优先级和调度策略（调度），信号屏蔽字（不同线程的任务不同，想要响应的信号也不同），errno变量（不同线程的错误状态不同）。
- 线程还需要私有变量区。这一部分相当于线程自己的私有堆，物理上是在进程的堆中开辟的，由一个本进程所有线程共享的全局变量标志哪个堆归哪个线程私有。本来线程是不允许有的私有堆的。每个线程确实需要在执行过程中产生一些私有的变量，这些变量可以放在进程的堆中，但是，这样会造成这些变量被所有线程共享了（这是不希望的）。如果线程的所有临时变量都放在栈帧中，那么多个栈帧共享的变量就要在每一个栈帧中保存一个副本，造成重复构造和释放，使得线程执行效率底下。于是，就出现了线程私有堆的概念。在Java中，是ThreadLocal这个类实现了线程的私有堆。

#### **3. 一个进程中都有哪些数据被线程共享**

一个进程的所有信息和资源都被线程共享，包括：可执行的代码，全局变量，常量池，静态区，全局缓冲区，堆（前面那些都是堆的一部分），文件描述符等。
