---
layout: post
post: true
title: Java虚拟机中的垃圾收集
date: 2019-10-20
category: Java虚拟机
tag: GC, Jvm, Java
author: Feng Yuan
---

* content
{: toc}


### **1. GC简介**

GC(Garbage Collection)：即垃圾回收器，诞生于1960年MIT的Lisp语言，主要是用来回收，释放垃圾占用的空间。

java GC泛指java的垃圾回收机制，该机制是java与C/C++的主要区别之一，我们在日常写java代码的时候，一般都不需要编写内存回收或者垃圾清理的代码，也不需要像C/C++那样做类似delete/free的操作，因为JVM自动帮助我们在堆中完成了GC。

### **2. GC的用处**

在java内存模型的五大区域中，我们知道**程序计数器、虚拟机栈、本地方法栈**，由线程而生，随线程而灭，其中栈中的栈帧随着方法的进入顺序的执行的入栈和出栈的操作，一个栈帧需要分配多少内存取决于具体的虚拟机实现并且在编译期间即确定下来(忽略JIT编译器做的优化，基本当成编译期间可知)，当方法或线程执行完毕后，内存就随着回收，因此无需关心。

而**Java堆、方法区**则不一样。方法区存放着类加载信息，但是一个接口中多个实现类需要的内存可能不太一样，一个方法中多个分支需要的内存也可能不一样(只有在运行期间才可知道这个方法创建了哪些对象没需要多少内存)，这部分内存的分配和回收都是动态的，gc关注的也正是这部分的内存。

所以，Java堆是GC回收的“重点区域”，堆一般也被称为GC堆的原因。堆中基本存放着所有对象实例，gc进行回收前，第一件事就是确认哪些对象存活，哪些死去(即不可能再被引用)。

### **3. GC的基本原理**

GC的学习，主要是学习垃圾回收算法，至于对GC堆的分区操作，并发，增量GC，是为了解决GC的stop-the-world的问题出现的。GC的基本原理是很简单，而且不管什么算法，都不变的。

#### **GC一共就两种基本原理：**

*1. 引用计数算法*

早期判断对象是否存活大多都是以这种算法，这种算法判断很简单，简单来说就是给对象添加一个引用计数器，每当对象被引用一次就加1，引用失效时就减1。当为0的时候就判断对象不会再被引用。

优点:实现简单效率高，被广泛使用与如python何游戏脚本语言上。

缺点:难以解决循环引用的问题，就是假如两个对象互相引用已经不会再被其它其它引用，导致一直不会为0就无法进行回收。

*2. 可达性分析算法*

目前主流的商用语言(如java、c#)采用的是可达性分析算法判断对象是否存活。这个算法有效解决了循环利用的弊端。

它的基本思路是通过一个称为“GC Roots”的对象为起始点，搜索所经过的路径称为引用链，当一个对象到GC Roots没有任何引用跟它连接则证明对象是不可用的。

>即使可达性算法中不可达的对象，也不是一定要马上被回收，还有可能被抢救一下。
>要真正宣告对象死亡需经过两个过程。
>1.可达性分析后没有发现引用链
>2.查看对象是否有finalize方法，如果有重写且在方法内完成自救\[比如再建立引用\]，还是可以抢救一下，注意这边一个类的finalize只执行一次，这就会出现一样的代码第一次自救成功第二>次失败的情况。\[如果类重写finalize且还没调用过，会将这个对象放到一个叫做F-Queue的序列里，这边finalize不承诺一定会执行，这么做是因为如果里面死循环的话可能会时F-Queue队列处于等待，严重会导致内存崩溃，这是我们不希望看到的。\]

#### **可以作为GC Roots的对象**

本质上，是使用tracing GC的“根集合”，就是**一组必须活跃的引用**(注意，是引用，而不是具体的对象自身)

1. \[虚拟机栈中指向Java堆的引用\]所有Java线程当前活跃的栈帧里指向GC堆里的对象的引用；换句话说，当前所有正在被调用的方法的引用类型的参数/局部变量/临时值。(虚拟机栈(栈桢中的本地变量表)中的引用的对象，就是平时所指的java对象，存放在堆中);
2. \[虚拟机环境中指向Java堆的引用\]JVM的一些静态数据结构里指向GC堆里的对象的引用；例如说HotSpot VM里的Universe里有很多这样的引用;
3. \[Native栈中指向Java堆的引用\]本地方法栈中JNI(native方法)引用的对象;
4. \[方法区\]所有当前被加载的**Java类**；
5. \[方法区\]Java类的**引用类型静态变量**；
6. \[方法区\]Java类的运行时**常量池里的引用类型常量**（String或Class类型）;
7. \[方法区\]String常量池（StringTable）里的引用;

前三项是必须包含的GC Roots，而后面几项是要看情况。虚拟机栈和Native栈中的对象引用，是必须作为GC Roots的，这个很好理解。

### **3. Stop-the-world(非并发)类 GC算法**

jvm中，可达性分析帮我们解决了哪些对象可以回收的问题，垃圾收集算法则关心怎么回收。不同的垃圾收集算法有各自不同的优缺点，在JVM实现中，往往不是采用单一的一种算法进行回收，而是采用几种不同的算法组合使用，来达到最好的收集效果。

**Stop-the-world**类型的GC算法。早期的GC算法，只能通过Stop-the-world来实现，需要暂停应用的运行，然后，对整个GC堆，运行GC算法。原因是在标记阶段进行可达性分析时，不可以出现分析过程中对象引用关系还在不断变化的情况，否则的话可达性分析结果的准确性就无法得到保证。在等待标记清除结束后，应用线程才会恢复运行。

这一类算法一般分为Serial的和Parallel的。Serial是单线程收集器，Serial收集器只能使用一条线程进行收集工作，在收集的时候必须得停掉其它线程，等待收集工作完成其它线程才可以继续工作(这是在jdk1.3之前的唯一选择)。Parallel是Serial的升级版(并行版本)，它支持多线程\[也就是开启多个GC线程来进行GC\]，而且收集算法、Stop The World、回收策略和Serial一样，就是可以有多个GC线程并发运行，它是HotSpot第一个真正意义实现并发的收集器，默认开启线程数和当前cpu数量相同。(注意区分，Parallel与并发类GC算法并不一样，不同的教程对"并发"这个词指代的意义不同，这里，我们专指使得*GC*和*应用*并发的叫并发类GC算法，而单纯在GC中使用多线程的叫Parallel类的Stop-the-World GC算法)

#### 3.1 标记－清除

最基础的GC算法。标记/清除算法的基本思想就跟它的名字一样，分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。

标记阶段：标记的过程其实就是**可达性分析算法**的过程，遍历所有的GC Roots对象，对从GC Roots对象可达的对象都打上一个标识，一般是在对象的header中，将其记录为可达对象；

清除阶段：清除的过程是对GC堆内存进行遍历，如果发现某个对象没有被标记为可达对象（通过读取对象header信息），则将其回收。

&nbsp;
<div align="center"><img src="/assets/img/2019/10/20/gc_mark_sweep.jpg" width="60%"/><p>Fig.1 Garbage Collection Mark and Sweep</p></div>
&nbsp;

Mark-Sweep的缺点：

1. 效率问题。标记和清除两个阶段的效率都不高，因为这两个阶段都需要遍历内存中的对象，很多时候内存中的对象实例数量是非常庞大的，这无疑很耗费时间，而且GC时需要停止应用程序，这会导致非常差的用户体验。
2. 空间问题。标记清除之后会产生大量不连续的内存碎片（从上图可以看出），内存空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾回收动作。

#### 3.2 标记－复制

解决**标记－清除**算法中的空间问题的一种解决方案。

复制算法的原理是：将可用内存按容量划分为大小相等的两块，每次使用其中的一块。当这一块的内存用完了，就将还存活的对象复制到另一块内存上，然后把这一块内存所有的对象一次性清理掉。

回收前：
&nbsp;
<div align="center"><img src="/assets/img/2019/10/20/gc_mark_copy_1.jpg" width="80%"/><p>Fig.2 Garbage Collection Mark and Copy Before GC</p></div>
&nbsp;

回收后:
&nbsp;
<div align="center"><img src="/assets/img/2019/10/20/gc_mark_copy_2.jpg" width="80%"/><p>Fig.3 Garbage Collection Mark and Copy After GC</p></div>
&nbsp;

复制算法每次都是对整个半区进行内存回收，这样就减少了标记对象遍历的时间，在清除使用区域对象时，不用进行遍历，直接清空整个区域内存，而且在将存活对象复制到保留区域时也是按地址顺序存储的，这样就解决了内存碎片的问题，在分配对象内存时不用考虑内存碎片等复杂问题，只需要按顺序分配内存即可。

复制算法简单高效，优化了标记/清除算法的效率低、内存碎片多的问题。但是它的缺点也很明显：
1. 将内存缩小为原来的一半，浪费了一半的内存空间，代价太高；
2. 如果对象的存活率很高，极端一点的情况假设对象存活率为100%，那么我们需要将所有存活的对象复制一遍，耗费的时间代价也是不可忽视的。

#### 3.3 标记－压缩(整理)

复制算法在对象存活率较高时要进行较多的复制操作，效率会变得很低，更关键的是，如果不想浪费50%的内存空间，就需要有额外的内存空间进行分配担保，以应对内存中对象100%存活的极端情况。标记/整理算法的标记过程任然与标记/清除算法一样，但后续步骤不是直接对可回收对象进行回收，而是让所有存活的对象都向一端移动，然后直接清理掉端边线以外的内存。

回收前：
&nbsp;
<div align="center"><img src="/assets/img/2019/10/20/gc_mark_compress_1.jpg" width="80%"/><p>Fig.4 Garbage Collection Mark and Compress Before GC</p></div>
&nbsp;

回收后:
&nbsp;
<div align="center"><img src="/assets/img/2019/10/20/gc_mark_compress_2.jpg" width="80%"/><p>Fig.5 Garbage Collection Mark and Compress After GC</p></div>
&nbsp;

回收后可回收对象被清理掉了，存活的对象按规则排列存放在内存中。这样一来，当我们给新对象分配内存时，jvm只需要持有内存的起始地址即可。标记/整理算法不仅弥补了标记/清除算法存在内存碎片的问题，也消除了复制算法内存减半的高额代价，可谓一举两得。但任何算法都有缺点，就像人无完人，标记/整理算法的缺点就是效率也不高，不仅要标记存活对象，还要整理所有存活对象的引用地址，在效率上不如复制算法。

#### 3.4 小结

**效率**：复制算法 > 标记-压缩算法 > 标记-清除算法（标记-清除算法有内存碎片问题，给大对象分配内存时可能会触发新一轮垃圾回收）

**内存整齐率**：复制算法 = 标记-压缩算法 > 标记-清除算法

**内存利用率**：标记-压缩算法 = 标记-清除算法 > 复制算法

### **４. 非Stop-the-wold(并发)类 GC算法**

上述方法都需要Stop-the-world，这样就使得在GC运行时，应用完全停滞，用户体验很不好。比较先进的GC方法采用部分并发或者完全并发的方式，在GC运行过程中，并不停止应用的运行。

#### **4.1. CMS(Concurrent Mark Sweep)**

最早期的方法是部分并发式，CMS收集器(Concurrent Mark Sweep)是以一种获取最短回收停顿时间为目标的收集器。\[重视响应，可以带来好的用户体验，被sun称为并发低停顿收集器\]

正如其名，CMS采用的是"标记-清除"(Mark Sweep)算法，而且是支持并发(Concurrent)的。

CMS的运行有四个阶段：
1. 初始标记:标记一下GC Roots能直接关联到的对象，速度很快
2. 并发标记:GC Roots Tarcing过程，即可达性分析
3. 重新标记:为了修正因并发标记期间用户程序运作而产生变动的那一部分对象的标记记录，会有些许停顿，时间上一般 初始标记 < 重新标记 < 并发标记
4. 并发清除

初始标记和重新标记需要stop-the-world(停掉其它运行java线程)，其他阶段不需要。这也是CMS被称为部分并发的原因。

CMS的缺点：
1. cms堆cpu特别敏感，cms运行线程和应用程序并发执行需要多核cpu，如果cpu核数多的话可以发挥它并发执行的优势，但是cms默认配置启动的时候垃圾线程数为 (cpu数量+3)/4，它的性能很容易受cpu核数影响，当cpu的数目少的时候比如说为为2核，如果这个时候cpu运算压力比较大，还要分一半给cms运作，这可能会很大程度的影响到计算机性能；
2. cms无法处理浮动垃圾，可能导致Concurrent Mode Failure（并发模式故障）而触发full GC；
3. 由于cms是采用"标记-清除“算法,因此就会存在垃圾碎片的问题，为了解决这个问题cms提供了 -XX:+UseCMSCompactAtFullCollection选项，这个选项相当于一个开关\[默认开启\]，用于CMS顶不住要进行full GC时开启内存碎片合并，内存整理的过程是无法并发的，且开启这个选项会影响性能(比如停顿时间变长)。

>浮动垃圾:由于cms支持运行的时候用户线程也在运行，程序运行的时候会产生新的垃圾，这里产生的垃圾就是浮动垃圾，cms无法当次处理，得等下次才可以。

#### **4.2 G1 算法**

G1(garbage first:尽可能多收垃圾，避免full gc)收集器是当前最为前沿的收集器之一(1.7以后才开始有)，同cms一样也是关注降低延迟，是用于替代cms功能更为强大的新型收集器，因为它解决了cms产生空间碎片等一系列缺陷。

G1的特别之处在于它强化了分区，弱化了分代的概念，是**区域化、增量式、并发式**的收集器，它不属于新生代也不属于老年代收集器。

G1是区域化的，它将java堆内存划分为若干个大小相同的区域\[region\]，jvm可以设置每个region的大小(1-32m,大小得看堆内存大小，必须是2的幂),它会根据当前的堆内存分配合理的region大小。G1不再区分老年代、年轻代这样的内存空间，这是较以往收集器很大的差异，所有的内存空间就是一块划分为不同子区域，最多支持的内存为64g左右，它为了的特性适用于大内存机器。

&nbsp;
<div align="center"><img src="/assets/img/2019/10/20/gc_g1_region.png" width="80%"/><p>Fig.6 Garbage Collection G1 Regions</p></div>
&nbsp;

G1的适用场景：
1. 像cms能与应用程序并发执行，GC停顿短，用户体验好的场景。
2. 面向服务端，大内存，高CPU负载的应用机器。
3. 应用在运行过程中经常会产生大量内存碎片，需要压缩空间\[比cms好的地方之一，g1具备压缩功能\]

#### **4.3 其他算法**

Azul Systems的Zing JVM里的C4 GC，一个完全并发的GC算法。不存在“GC整个工作流程中都要把应用stop-the-world”的问题——从算法的设计上就不存在。

Red Hat的Shenandoah GC是一个并发GC。

### **５. GC堆的分区/代**

GC与应用并发，是一种解决Stop-the-world问题的思路。对GC堆分区，是另一种缓解STW问题的思路。前者是利用多CPU的优势，在时间域上缓解STW，比如CMS，而后者则是利用空间上的结构设计缓解STW。两种解决方案是独立的。当然，它们也可以结合，实现更加强大的GC算法，比如上面提到的G1算法就是一种综合性的GC算法。

***分代结构***

分代收集算法的思想是按对象的存活周期不同将内存划分为几块，一般是把Java堆分为新生代和老年代（还有一个永久代，是HotSpot特有的实现，其他的虚拟机实现没有这一概念，永久代的收集效果很差，一般很少对永久代进行垃圾回收），这样就可以根据各个年代的特点采用最合适的收集算法。

**新生代(young gen)**：朝生夕灭，存活时间很短。

**老年代(old gen)**：经过多次Minor GC而存活下来，存活周期长。

**伊甸园(eden)**：新生代中的一个子区域，所有新建的对象，都放在Eden中。

**存活区(survivor)**：新生代的一个子区域，其被进一步分解成To Survivor和From Survivor两个区域。

我们可以看到，这里面是一个两级的缓冲结构(young gen继续被细分)，而不是young gen-old gen这种单级的结构。道理跟CPU中使用多级Cache是一样的，提高效率。

&nbsp;
<div align="center"><img src="/assets/img/2019/10/20/gc_gen_structure.jpg" width="80%"/><p>Fig.7 Garbage Collection Generation Splitting</p></div>
&nbsp;

*注意*：使用了分代后，GC Roots中需要加入没有参与GC过程的区域的对象引用。比如仅仅对young gen进行GC的时候，old gen中的对象的引用也需要作为GC Roots进行存活性判定。

***对象晋升规则***

1. 对象优先分配在eden区，eden区满时会触发一次minor GC;
2. 长期存活的对象进入老年代，对象每熬过一次GC年龄+1(默认年龄阈值15，可配置);
3. 对象太大，新生代无法容纳则会分配到老年代;
4. eden区满了，进行minor gc后，eden和一个survivor区仍然存活的对象无法放到(to survivor区)则会通过分配担保机制放到老年代，这种情况一般是minor gc后新生代存活的对象太多；
5. 动态年龄判定，为了使内存分配更灵活，jvm不一定要求对象年龄达到MaxTenuringThreshold(15)才晋升为老年代，若survior区相同年龄对象总大小大于survior区空间的一半，则大于等于这个年龄的对象将会在minor gc时移到老年代。

***为什么要分代***

第一个原因(缓解STW)：

对传统的、基本的GC实现来说，由于它们在GC的整个工作过程中都要“stop-the-world”，如果能想办法缩短GC一次工作的时间长度就是件重要的事情。如果说收集整个GC堆耗时太长，那不如只收集其中的一部分？于是就有好几种不同的划分（partition）GC堆的方式来实现部分收集，而分代式GC就是这其中的一个思路。

这个思路所基于的基本假设：weak generational hypothesis——大部分对象的生命期很短（die young），而没有die young的对象则很可能会存活很长时间（live long）。

第二个原因(提高内存分配速率)：

对于自带并发的GC算法(G1, CMS等), 解决stop-the-world时间太长的问题并不是选择分代的主要原因，而是分代使得GC能够应付的应用内存分配速率（allocation rate）可以得到巨大的提升。

并发GC根本上要跟应用玩追赶游戏：应用一边在分配，GC一边在收集，如果GC收集的速度能跟得上应用分配的速度，那就一切都很完美；一旦GC开始跟不上了，垃圾就会渐渐堆积起来，最终到可用空间彻底耗尽的时候，应用的分配请求就只能暂时等一等了，等GC追赶上来。

所以，对于一个并发GC来说，能够尽快回收出越多空间，就能够应付越高的应用内存分配速率，从而更好地保持GC以完美的并发模式工作。分代可以让并发GC在不同的代上使用不同的GC算法，这样就可以最快的完成垃圾收集。

***不同代中的GC算法***

基于标记－复制算法的缺点，由于新生代中的对象几乎都是“朝生夕死”的（达到98%），现在的商业虚拟机都采用复制算法来回收新生代。

在老年代中由于对象的存活率非常高，复制算法就不合适了，根据老年代的特点，应该使用标记－整理算法，实际中，使用CMS算法来提高并行度。

由于新生代的对象存活率低，所以并不需要按照1：1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的From Survivor空间、To Survivor空间，三者的比例为8：1：1。每次使用Eden和From Survivor区域，To Survivor作为保留空间。GC开始时，对象只会存在于Eden区和From Survivor区，To Survivor区是空的。GC进行时，Eden区中所有存活的对象都会被复制到To Survivor区，而在From Survivor区中，仍存活的对象会根据它们的年龄值决定去向，年龄值达到年龄阀值（默认为15，新生代中的对象每熬过一轮垃圾回收，年龄值就加1）的对象会被移到老年代中，没有达到阀值的对象会被复制到To Survivor区。接着清空Eden区和From Survivor区，新生代中存活的对象都在To Survivor区。接着， From Survivor区和To Survivor区会交换它们的角色，也就是新的To Survivor区就是上次GC清空的From Survivor区，新的From Survivor区就是上次GC的To Survivor区，总之，不管怎样都会保证To Survivor区在一轮GC后是空的。GC时当To Survivor区没有足够的空间存放上一次新生代收集下来的存活对象时，需要依赖老年代进行分配担保，将这些对象存放在老年代中。

&nbsp;
<div align="center"><img src="/assets/img/2019/10/20/gc_gen_result.jpg" width="80%"/><p>Fig.8 Garbage Collection Generation Summary</p></div>
&nbsp;

### **6.不同的GC名词**

#### 6.1 Minor GC

在年轻代Young space(包括Eden区和Survivor区)中的垃圾回收称之为 Minor GC,Minor GC只会清理年轻代.

#### 6.2 Major GC

Major GC清理老年代(old GC)，但是通常也可以指和Full GC是等价，因为收集老年代的时候往往也会伴随着升级年轻代，收集整个Java堆。所以有人问的时候需问清楚它指的是full GC还是old GC。

#### 6.3 Full GC

full gc是对新生代、老年代、永久代\[jdk1.8后没有这个概念了，换成元空间\]统一的回收。

#### 6.4 Mixed GC

收集整个young gen以及部分old gen的GC。只有G1有这个模式。

### **7.空间分配担保**

在minor gc前，jvm会先检查老年代最大可用空间是否大于新生代所有对象总空间，如果是的话，则minor gc可以确保是安全的。

否则，会检查一个配置(HandlePromotionFailure),即是否允许担保失败。如果不允许，而且还小于的情况，则会触发full gc。如果允许，继续检查老年代最大可用可用的连续空间是否大于之前晋升的平均大小，比如说剩10m，之前每次都有9m左右的新生代到老年代，那么将尝试一次minor gc(大于的情况)，这会比较冒险。因为，如果突然有一次minor gc对象变得很多远高于以往的平均值，这个时候就会导致担保失败，这就只好触发一次full gc，用来清理old gen，以腾出更多的空间。

这边为什么说是冒险是因为minor gc过后如果出现大对象，由于新生代采用复制算法，survivor无法容纳将跑到老年代，所以才会去计算之前的平均值作为一种担保的条件与老年代剩余空间比较，这就是分配担保。

### **8.GC的触发时机**

简单来说，触发的条件就是GC算法区域满了或将满了。

minor GC(young GC):当年轻代中eden区分配满的时候触发\[值得一提的是因为young GC后部分存活的对象会已到老年代(比如对象熬过15轮)，所以过后old gen的占用量通常会变高\]

full GC:
1. 手动调用System.gc()方法\[增加了full GC频率，不建议使用而是让jvm自己管理内存，可以设置-XX:+ DisableExplicitGC来禁止RMI调用System.gc\]；
2. 发现perm gen(如果存在永久代的话)需分配空间但已经没有足够空间；
3. 老年代空间不足，比如说新生代的大对象大数组晋升到老年代就可能导致老年代空间不足；
4. CMS GC时出现Promotion Failed\[pf\]错误；
5. 统计得到的Minor GC晋升到旧生代的平均大小大于老年代的剩余空间；
这个比较难理解，这是HotSpot为了避免由于新生代晋升到老年代导致老年代空间不足而触发的FUll GC。
比如程序第一次触发Minor GC后，有5m的对象晋升到老年代，姑且现在平均算5m，那么下次Minor GC发生时，先判断现在老年代剩余空间大小是否超过5m，如果小于5m，则HotSpot则会触发full GC(这点挺智能的)

Promotion Faield:minor GC时 survivor space放不下\[满了或对象太大\]，对象只能放到老年代，而老年代也放不下会导致这个错误。
